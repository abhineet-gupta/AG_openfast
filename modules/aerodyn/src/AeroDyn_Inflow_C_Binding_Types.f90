!STARTOFREGISTRYGENERATEDFILE 'AeroDyn_Inflow_C_Binding_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AeroDyn_Inflow_C_Binding_Types
!.................................................................................................................................
! This file is part of AeroDyn_Inflow_C_Binding.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AeroDyn_Inflow_C_Binding. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AeroDyn_Inflow_C_Binding_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: NumPtsDiskAvg = 144      ! Number of points for disk average velocity calculations [-]
! =========  DiskAvgVelData  =======
  TYPE, PUBLIC :: DiskAvgVelData
    REAL(ReKi) , DIMENSION(1:3,1:NumPtsDiskAvg)  :: DiskWindPosRel = 0.0_ReKi      !< Position points for disk average sampling, relative to hub [-]
    REAL(ReKi) , DIMENSION(1:3,1:NumPtsDiskAvg)  :: DiskWindPosAbs = 0.0_ReKi      !< Position points for disk average sampling, absolute/global/interial [-]
    REAL(ReKi) , DIMENSION(1:3,1:NumPtsDiskAvg)  :: DiskWindVel = 0.0_ReKi      !< Velocity at disk average sampling points [-]
    REAL(ReKi) , DIMENSION(1:3)  :: DiskAvgVel = 0.0_ReKi      !< Average velocity calculated from DiskWindVel [-]
  END TYPE DiskAvgVelData
! =======================
! =========  BladeNodeToMeshPointMapType  =======
  TYPE, PUBLIC :: BladeNodeToMeshPointMapType
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BladeNodeToMeshPoint      !< Blade node -> structural mesh point mapping (sized by the number of nodes on the blade) [-]
  END TYPE BladeNodeToMeshPointMapType
! =======================
! =========  BladeStrMeshCoordsType  =======
  TYPE, PUBLIC :: BladeStrMeshCoordsType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Position      !< Position of all blade points (sized by 3 x number of mesh points on the blade [x,y,z]) [m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Orient      !< Orientation of all blade points (sized by 3 x 3 x number of mesh points on the blade [r11,r12,r13,r21,r22,r23,r31,r32,r33]) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Velocity      !< Velocity of all blade points (sized by 6 x number of mesh points on the blade [u,v,w,p,q,r]) [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Accln      !< Acceleration of all blade points (sized by 6 x number of mesh points on the blade [udot,vdot,wdot,pdot,qdot,rdot]) [m/s^2]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Force      !< Force of all blade points (sized by 6 x number of mesh points on the blade [Fx,Fy,Fz,Mx,My,Mz]) [N,Nm]
  END TYPE BladeStrMeshCoordsType
! =======================
! =========  StrucPtsToBladeMapType  =======
  TYPE, PUBLIC :: StrucPtsToBladeMapType
    INTEGER(IntKi)  :: NumBlades = 0_IntKi      !< Number of blades on this rotor [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NumMeshPtsPerBlade      !< Number of structural mesh points on each blade (sized by the number of blades) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: MeshPt_2_BladeNum      !< Structural mesh point -> which blade on the rotor it is on (sized by the number of mesh points on the rotor) [-]
    TYPE(BladeNodeToMeshPointMapType) , DIMENSION(:), ALLOCATABLE  :: BladeNode_2_MeshPt      !< Blade node on blade -> structural mesh point (sized by the number of mesh points on the blade) [-]
    TYPE(BladeStrMeshCoordsType) , DIMENSION(:), ALLOCATABLE  :: BladeStrMeshCoords      !< Mesh point coordinates for each blade (sized by the number of blades) [-]
  END TYPE StrucPtsToBladeMapType
! =======================
! =========  MeshByBladeType  =======
  TYPE, PUBLIC :: MeshByBladeType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BldMesh      !< Mesh for motions/loads of external nodes at each blade (sized by number of blades on the rotor) [-]
  END TYPE MeshByBladeType
! =======================
CONTAINS

subroutine ADI_cbind_CopyDiskAvgVelData(SrcDiskAvgVelDataData, DstDiskAvgVelDataData, CtrlCode, ErrStat, ErrMsg)
   type(DiskAvgVelData), intent(in) :: SrcDiskAvgVelDataData
   type(DiskAvgVelData), intent(inout) :: DstDiskAvgVelDataData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'ADI_cbind_CopyDiskAvgVelData'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDiskAvgVelDataData%DiskWindPosRel = SrcDiskAvgVelDataData%DiskWindPosRel
   DstDiskAvgVelDataData%DiskWindPosAbs = SrcDiskAvgVelDataData%DiskWindPosAbs
   DstDiskAvgVelDataData%DiskWindVel = SrcDiskAvgVelDataData%DiskWindVel
   DstDiskAvgVelDataData%DiskAvgVel = SrcDiskAvgVelDataData%DiskAvgVel
end subroutine

subroutine ADI_cbind_DestroyDiskAvgVelData(DiskAvgVelDataData, ErrStat, ErrMsg)
   type(DiskAvgVelData), intent(inout) :: DiskAvgVelDataData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'ADI_cbind_DestroyDiskAvgVelData'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine ADI_cbind_PackDiskAvgVelData(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(DiskAvgVelData), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'ADI_cbind_PackDiskAvgVelData'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DiskWindPosRel)
   call RegPack(RF, InData%DiskWindPosAbs)
   call RegPack(RF, InData%DiskWindVel)
   call RegPack(RF, InData%DiskAvgVel)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine ADI_cbind_UnPackDiskAvgVelData(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(DiskAvgVelData), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'ADI_cbind_UnPackDiskAvgVelData'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DiskWindPosRel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DiskWindPosAbs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DiskWindVel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%DiskAvgVel); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine ADI_cbind_CopyBladeNodeToMeshPointMapType(SrcBladeNodeToMeshPointMapTypeData, DstBladeNodeToMeshPointMapTypeData, CtrlCode, ErrStat, ErrMsg)
   type(BladeNodeToMeshPointMapType), intent(in) :: SrcBladeNodeToMeshPointMapTypeData
   type(BladeNodeToMeshPointMapType), intent(inout) :: DstBladeNodeToMeshPointMapTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'ADI_cbind_CopyBladeNodeToMeshPointMapType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint)) then
      LB(1:1) = lbound(SrcBladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint)
      UB(1:1) = ubound(SrcBladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint)
      if (.not. allocated(DstBladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint)) then
         allocate(DstBladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint = SrcBladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint
   end if
end subroutine

subroutine ADI_cbind_DestroyBladeNodeToMeshPointMapType(BladeNodeToMeshPointMapTypeData, ErrStat, ErrMsg)
   type(BladeNodeToMeshPointMapType), intent(inout) :: BladeNodeToMeshPointMapTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'ADI_cbind_DestroyBladeNodeToMeshPointMapType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint)) then
      deallocate(BladeNodeToMeshPointMapTypeData%BladeNodeToMeshPoint)
   end if
end subroutine

subroutine ADI_cbind_PackBladeNodeToMeshPointMapType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(BladeNodeToMeshPointMapType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'ADI_cbind_PackBladeNodeToMeshPointMapType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%BladeNodeToMeshPoint)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine ADI_cbind_UnPackBladeNodeToMeshPointMapType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(BladeNodeToMeshPointMapType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'ADI_cbind_UnPackBladeNodeToMeshPointMapType'
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%BladeNodeToMeshPoint); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine ADI_cbind_CopyBladeStrMeshCoordsType(SrcBladeStrMeshCoordsTypeData, DstBladeStrMeshCoordsTypeData, CtrlCode, ErrStat, ErrMsg)
   type(BladeStrMeshCoordsType), intent(in) :: SrcBladeStrMeshCoordsTypeData
   type(BladeStrMeshCoordsType), intent(inout) :: DstBladeStrMeshCoordsTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'ADI_cbind_CopyBladeStrMeshCoordsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcBladeStrMeshCoordsTypeData%Position)) then
      LB(1:2) = lbound(SrcBladeStrMeshCoordsTypeData%Position)
      UB(1:2) = ubound(SrcBladeStrMeshCoordsTypeData%Position)
      if (.not. allocated(DstBladeStrMeshCoordsTypeData%Position)) then
         allocate(DstBladeStrMeshCoordsTypeData%Position(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeStrMeshCoordsTypeData%Position.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeStrMeshCoordsTypeData%Position = SrcBladeStrMeshCoordsTypeData%Position
   end if
   if (allocated(SrcBladeStrMeshCoordsTypeData%Orient)) then
      LB(1:3) = lbound(SrcBladeStrMeshCoordsTypeData%Orient)
      UB(1:3) = ubound(SrcBladeStrMeshCoordsTypeData%Orient)
      if (.not. allocated(DstBladeStrMeshCoordsTypeData%Orient)) then
         allocate(DstBladeStrMeshCoordsTypeData%Orient(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeStrMeshCoordsTypeData%Orient.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeStrMeshCoordsTypeData%Orient = SrcBladeStrMeshCoordsTypeData%Orient
   end if
   if (allocated(SrcBladeStrMeshCoordsTypeData%Velocity)) then
      LB(1:2) = lbound(SrcBladeStrMeshCoordsTypeData%Velocity)
      UB(1:2) = ubound(SrcBladeStrMeshCoordsTypeData%Velocity)
      if (.not. allocated(DstBladeStrMeshCoordsTypeData%Velocity)) then
         allocate(DstBladeStrMeshCoordsTypeData%Velocity(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeStrMeshCoordsTypeData%Velocity.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeStrMeshCoordsTypeData%Velocity = SrcBladeStrMeshCoordsTypeData%Velocity
   end if
   if (allocated(SrcBladeStrMeshCoordsTypeData%Accln)) then
      LB(1:2) = lbound(SrcBladeStrMeshCoordsTypeData%Accln)
      UB(1:2) = ubound(SrcBladeStrMeshCoordsTypeData%Accln)
      if (.not. allocated(DstBladeStrMeshCoordsTypeData%Accln)) then
         allocate(DstBladeStrMeshCoordsTypeData%Accln(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeStrMeshCoordsTypeData%Accln.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeStrMeshCoordsTypeData%Accln = SrcBladeStrMeshCoordsTypeData%Accln
   end if
   if (allocated(SrcBladeStrMeshCoordsTypeData%Force)) then
      LB(1:2) = lbound(SrcBladeStrMeshCoordsTypeData%Force)
      UB(1:2) = ubound(SrcBladeStrMeshCoordsTypeData%Force)
      if (.not. allocated(DstBladeStrMeshCoordsTypeData%Force)) then
         allocate(DstBladeStrMeshCoordsTypeData%Force(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstBladeStrMeshCoordsTypeData%Force.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstBladeStrMeshCoordsTypeData%Force = SrcBladeStrMeshCoordsTypeData%Force
   end if
end subroutine

subroutine ADI_cbind_DestroyBladeStrMeshCoordsType(BladeStrMeshCoordsTypeData, ErrStat, ErrMsg)
   type(BladeStrMeshCoordsType), intent(inout) :: BladeStrMeshCoordsTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'ADI_cbind_DestroyBladeStrMeshCoordsType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(BladeStrMeshCoordsTypeData%Position)) then
      deallocate(BladeStrMeshCoordsTypeData%Position)
   end if
   if (allocated(BladeStrMeshCoordsTypeData%Orient)) then
      deallocate(BladeStrMeshCoordsTypeData%Orient)
   end if
   if (allocated(BladeStrMeshCoordsTypeData%Velocity)) then
      deallocate(BladeStrMeshCoordsTypeData%Velocity)
   end if
   if (allocated(BladeStrMeshCoordsTypeData%Accln)) then
      deallocate(BladeStrMeshCoordsTypeData%Accln)
   end if
   if (allocated(BladeStrMeshCoordsTypeData%Force)) then
      deallocate(BladeStrMeshCoordsTypeData%Force)
   end if
end subroutine

subroutine ADI_cbind_PackBladeStrMeshCoordsType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(BladeStrMeshCoordsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'ADI_cbind_PackBladeStrMeshCoordsType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%Position)
   call RegPackAlloc(RF, InData%Orient)
   call RegPackAlloc(RF, InData%Velocity)
   call RegPackAlloc(RF, InData%Accln)
   call RegPackAlloc(RF, InData%Force)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine ADI_cbind_UnPackBladeStrMeshCoordsType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(BladeStrMeshCoordsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'ADI_cbind_UnPackBladeStrMeshCoordsType'
   integer(B4Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%Position); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Orient); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Velocity); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Accln); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Force); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine ADI_cbind_CopyStrucPtsToBladeMapType(SrcStrucPtsToBladeMapTypeData, DstStrucPtsToBladeMapTypeData, CtrlCode, ErrStat, ErrMsg)
   type(StrucPtsToBladeMapType), intent(in) :: SrcStrucPtsToBladeMapTypeData
   type(StrucPtsToBladeMapType), intent(inout) :: DstStrucPtsToBladeMapTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'ADI_cbind_CopyStrucPtsToBladeMapType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstStrucPtsToBladeMapTypeData%NumBlades = SrcStrucPtsToBladeMapTypeData%NumBlades
   if (allocated(SrcStrucPtsToBladeMapTypeData%NumMeshPtsPerBlade)) then
      LB(1:1) = lbound(SrcStrucPtsToBladeMapTypeData%NumMeshPtsPerBlade)
      UB(1:1) = ubound(SrcStrucPtsToBladeMapTypeData%NumMeshPtsPerBlade)
      if (.not. allocated(DstStrucPtsToBladeMapTypeData%NumMeshPtsPerBlade)) then
         allocate(DstStrucPtsToBladeMapTypeData%NumMeshPtsPerBlade(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstStrucPtsToBladeMapTypeData%NumMeshPtsPerBlade.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstStrucPtsToBladeMapTypeData%NumMeshPtsPerBlade = SrcStrucPtsToBladeMapTypeData%NumMeshPtsPerBlade
   end if
   if (allocated(SrcStrucPtsToBladeMapTypeData%MeshPt_2_BladeNum)) then
      LB(1:1) = lbound(SrcStrucPtsToBladeMapTypeData%MeshPt_2_BladeNum)
      UB(1:1) = ubound(SrcStrucPtsToBladeMapTypeData%MeshPt_2_BladeNum)
      if (.not. allocated(DstStrucPtsToBladeMapTypeData%MeshPt_2_BladeNum)) then
         allocate(DstStrucPtsToBladeMapTypeData%MeshPt_2_BladeNum(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstStrucPtsToBladeMapTypeData%MeshPt_2_BladeNum.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstStrucPtsToBladeMapTypeData%MeshPt_2_BladeNum = SrcStrucPtsToBladeMapTypeData%MeshPt_2_BladeNum
   end if
   if (allocated(SrcStrucPtsToBladeMapTypeData%BladeNode_2_MeshPt)) then
      LB(1:1) = lbound(SrcStrucPtsToBladeMapTypeData%BladeNode_2_MeshPt)
      UB(1:1) = ubound(SrcStrucPtsToBladeMapTypeData%BladeNode_2_MeshPt)
      if (.not. allocated(DstStrucPtsToBladeMapTypeData%BladeNode_2_MeshPt)) then
         allocate(DstStrucPtsToBladeMapTypeData%BladeNode_2_MeshPt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstStrucPtsToBladeMapTypeData%BladeNode_2_MeshPt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ADI_cbind_CopyBladeNodeToMeshPointMapType(SrcStrucPtsToBladeMapTypeData%BladeNode_2_MeshPt(i1), DstStrucPtsToBladeMapTypeData%BladeNode_2_MeshPt(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcStrucPtsToBladeMapTypeData%BladeStrMeshCoords)) then
      LB(1:1) = lbound(SrcStrucPtsToBladeMapTypeData%BladeStrMeshCoords)
      UB(1:1) = ubound(SrcStrucPtsToBladeMapTypeData%BladeStrMeshCoords)
      if (.not. allocated(DstStrucPtsToBladeMapTypeData%BladeStrMeshCoords)) then
         allocate(DstStrucPtsToBladeMapTypeData%BladeStrMeshCoords(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstStrucPtsToBladeMapTypeData%BladeStrMeshCoords.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call ADI_cbind_CopyBladeStrMeshCoordsType(SrcStrucPtsToBladeMapTypeData%BladeStrMeshCoords(i1), DstStrucPtsToBladeMapTypeData%BladeStrMeshCoords(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine ADI_cbind_DestroyStrucPtsToBladeMapType(StrucPtsToBladeMapTypeData, ErrStat, ErrMsg)
   type(StrucPtsToBladeMapType), intent(inout) :: StrucPtsToBladeMapTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'ADI_cbind_DestroyStrucPtsToBladeMapType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(StrucPtsToBladeMapTypeData%NumMeshPtsPerBlade)) then
      deallocate(StrucPtsToBladeMapTypeData%NumMeshPtsPerBlade)
   end if
   if (allocated(StrucPtsToBladeMapTypeData%MeshPt_2_BladeNum)) then
      deallocate(StrucPtsToBladeMapTypeData%MeshPt_2_BladeNum)
   end if
   if (allocated(StrucPtsToBladeMapTypeData%BladeNode_2_MeshPt)) then
      LB(1:1) = lbound(StrucPtsToBladeMapTypeData%BladeNode_2_MeshPt)
      UB(1:1) = ubound(StrucPtsToBladeMapTypeData%BladeNode_2_MeshPt)
      do i1 = LB(1), UB(1)
         call ADI_cbind_DestroyBladeNodeToMeshPointMapType(StrucPtsToBladeMapTypeData%BladeNode_2_MeshPt(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(StrucPtsToBladeMapTypeData%BladeNode_2_MeshPt)
   end if
   if (allocated(StrucPtsToBladeMapTypeData%BladeStrMeshCoords)) then
      LB(1:1) = lbound(StrucPtsToBladeMapTypeData%BladeStrMeshCoords)
      UB(1:1) = ubound(StrucPtsToBladeMapTypeData%BladeStrMeshCoords)
      do i1 = LB(1), UB(1)
         call ADI_cbind_DestroyBladeStrMeshCoordsType(StrucPtsToBladeMapTypeData%BladeStrMeshCoords(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(StrucPtsToBladeMapTypeData%BladeStrMeshCoords)
   end if
end subroutine

subroutine ADI_cbind_PackStrucPtsToBladeMapType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(StrucPtsToBladeMapType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'ADI_cbind_PackStrucPtsToBladeMapType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%NumBlades)
   call RegPackAlloc(RF, InData%NumMeshPtsPerBlade)
   call RegPackAlloc(RF, InData%MeshPt_2_BladeNum)
   call RegPack(RF, allocated(InData%BladeNode_2_MeshPt))
   if (allocated(InData%BladeNode_2_MeshPt)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeNode_2_MeshPt), ubound(InData%BladeNode_2_MeshPt))
      LB(1:1) = lbound(InData%BladeNode_2_MeshPt)
      UB(1:1) = ubound(InData%BladeNode_2_MeshPt)
      do i1 = LB(1), UB(1)
         call ADI_cbind_PackBladeNodeToMeshPointMapType(RF, InData%BladeNode_2_MeshPt(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%BladeStrMeshCoords))
   if (allocated(InData%BladeStrMeshCoords)) then
      call RegPackBounds(RF, 1, lbound(InData%BladeStrMeshCoords), ubound(InData%BladeStrMeshCoords))
      LB(1:1) = lbound(InData%BladeStrMeshCoords)
      UB(1:1) = ubound(InData%BladeStrMeshCoords)
      do i1 = LB(1), UB(1)
         call ADI_cbind_PackBladeStrMeshCoordsType(RF, InData%BladeStrMeshCoords(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine ADI_cbind_UnPackStrucPtsToBladeMapType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(StrucPtsToBladeMapType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'ADI_cbind_UnPackStrucPtsToBladeMapType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%NumBlades); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%NumMeshPtsPerBlade); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%MeshPt_2_BladeNum); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%BladeNode_2_MeshPt)) deallocate(OutData%BladeNode_2_MeshPt)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeNode_2_MeshPt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeNode_2_MeshPt.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ADI_cbind_UnpackBladeNodeToMeshPointMapType(RF, OutData%BladeNode_2_MeshPt(i1)) ! BladeNode_2_MeshPt 
      end do
   end if
   if (allocated(OutData%BladeStrMeshCoords)) deallocate(OutData%BladeStrMeshCoords)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BladeStrMeshCoords(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeStrMeshCoords.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ADI_cbind_UnpackBladeStrMeshCoordsType(RF, OutData%BladeStrMeshCoords(i1)) ! BladeStrMeshCoords 
      end do
   end if
end subroutine

subroutine ADI_cbind_CopyMeshByBladeType(SrcMeshByBladeTypeData, DstMeshByBladeTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MeshByBladeType), intent(inout) :: SrcMeshByBladeTypeData
   type(MeshByBladeType), intent(inout) :: DstMeshByBladeTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'ADI_cbind_CopyMeshByBladeType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMeshByBladeTypeData%BldMesh)) then
      LB(1:1) = lbound(SrcMeshByBladeTypeData%BldMesh)
      UB(1:1) = ubound(SrcMeshByBladeTypeData%BldMesh)
      if (.not. allocated(DstMeshByBladeTypeData%BldMesh)) then
         allocate(DstMeshByBladeTypeData%BldMesh(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMeshByBladeTypeData%BldMesh.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcMeshByBladeTypeData%BldMesh(i1), DstMeshByBladeTypeData%BldMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine ADI_cbind_DestroyMeshByBladeType(MeshByBladeTypeData, ErrStat, ErrMsg)
   type(MeshByBladeType), intent(inout) :: MeshByBladeTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'ADI_cbind_DestroyMeshByBladeType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MeshByBladeTypeData%BldMesh)) then
      LB(1:1) = lbound(MeshByBladeTypeData%BldMesh)
      UB(1:1) = ubound(MeshByBladeTypeData%BldMesh)
      do i1 = LB(1), UB(1)
         call MeshDestroy( MeshByBladeTypeData%BldMesh(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MeshByBladeTypeData%BldMesh)
   end if
end subroutine

subroutine ADI_cbind_PackMeshByBladeType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MeshByBladeType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'ADI_cbind_PackMeshByBladeType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%BldMesh))
   if (allocated(InData%BldMesh)) then
      call RegPackBounds(RF, 1, lbound(InData%BldMesh), ubound(InData%BldMesh))
      LB(1:1) = lbound(InData%BldMesh)
      UB(1:1) = ubound(InData%BldMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%BldMesh(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine ADI_cbind_UnPackMeshByBladeType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MeshByBladeType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'ADI_cbind_UnPackMeshByBladeType'
   integer(B4Ki)   :: i1
   integer(B4Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%BldMesh)) deallocate(OutData%BldMesh)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BldMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldMesh.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%BldMesh(i1)) ! BldMesh 
      end do
   end if
end subroutine
END MODULE AeroDyn_Inflow_C_Binding_Types
!ENDOFREGISTRYGENERATEDFILE
